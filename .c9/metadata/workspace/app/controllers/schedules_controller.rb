{"changed":false,"filter":false,"title":"schedules_controller.rb","tooltip":"/app/controllers/schedules_controller.rb","value":"class SchedulesController < ApplicationController\n  before_action :set_schedule, only: [:show, :edit, :update, :destroy]\n  before_action :set_session_user\n  before_action :set_user\n  before_action :set_semester\n  \n  before_filter :only_yours\n  \n  def index\n    @offerings = @user.schedules.where(semester: @active_semester).collect { |course| Offering.find(course.offering_id) }\n    @day_hash = view_context.create_day_hash(@offerings)\n    @new_work_schedule = WorkSchedule.new\n    @work_schedules = WorkSchedule.where(user: @user, semester: @active_semester)\n    @work_time_slots = WorkDaysTime.all\n    @majors = (Major.all.map { |major| [major.major, major.id] }) << [\"\", \"-1\"]\n    @minors = (Major.all.map { |major| [major.major, major.id] if @user.major_id != major.id}).compact\n  end\n\n  def new\n    @taken_courses, @category_courses   = scheduler(params[:user_id])\n    @work_schedules = WorkSchedule.where(user: @user, semester: @active_semester)\n    @schedules = @user.schedules.collect { |course| Offering.find(course.offering_id) }\n    @offerings = (@category_courses.values.reduce Hash.new, :merge).values.flatten.map { |offering| offering.id }\n    render :layout => false\n  end\n\n  def create\n    Schedule.delete_all(user: @user, semester: @active_semester)\n\n    @errors = []\n    (params[:schedule][:offering_id].reject! { |c| c.empty? }).each do |oid|\n      if not (sch = Schedule.create(user_id: @user.id, offering_id: oid, semester: @active_semester))\n        @errors << sch\n      end\n    end\n\n    @offerings = @user.schedules.where(semester: @active_semester).collect { |course| Offering.find(course.offering_id) }\n\n    respond_to do |format|\n      format.js {@errors}\n    end\n  end\n\n  private\n    # Use callbacks to share common setup or constraints between actions.\n    def set_session_user\n      @session_user = User.find(session[:user_id])\n    end\n    \n    def set_schedule\n      @schedule = Schedule.find(params[:id])\n    end\n\n    def set_user\n      @user = User.find(params[:user_id])\n    end\n    \n    def set_semester\n      @active_semester = Semester.where(active: true).take\n    end\n\n    # Never trust parameters from the scary internet, only allow the white list through.\n    def schedule_params\n      params.require(:schedule).permit(:user_id, :schedule => [:offering_id])\n    end\n    \n    def only_yours\n      logged_in = User.find_by_id(session[:user_id])\n      if not (logged_in.advisor or logged_in.administrator)\n        unless params[:user_id].to_i == session[:user_id].to_i\n          redirect_to user_transcripts_path(logged_in)\n        end\n      else\n        if User.find_by_id(params[:user_id]).advisor or User.find_by_id(params[:user_id]).administrator\n          redirect_to users_path, notice: \"Admins and Advisors don't have transcripts!\"\n        end\n      end\n    end\n\n    def prerequisite_check(courses, user_courses, user)\n      ok_courses = []\n      transcripts = Transcript.where(user: user)\n      courses.each do |course|\n        grouped_prerequisites = course.prerequisites.group_by(&:course_group_id)\n        \n        if not grouped_prerequisites.blank?\n          grouped_prerequisites.each do |group_id, prereq_group|\n            prereq_group.map! do |prereq| \n              passed, failed_grade = prereq_grade_checker(prereq, user_courses, transcripts)\n              if passed \n                true\n              else\n                if failed_grade != nil\n                  ok_courses << failed_grade\n                end\n                false\n              end\n            end\n            grouped_prerequisites[group_id] = prereq_group.inject(:&)\n          end\n          \n          if grouped_prerequisites.values.inject(:|) and class_standing_compare(user.class_standing,course.minimum_class_standing) and sat_check(user, course.minimum_sat_score)\n            ok_courses << course\n          end\n        else\n          ok_courses << course\n        end\n      end\n      return ok_courses\n    end\n    \n    def scheduler(uid) \n      user = User.find(uid)\n      used_courses = Set.new\n\n      active_semester = Semester.where(active: true).take\n      user_courses = Transcript.where(user_id: uid).map { |transcript| transcript.course } \n      \n      categories = CurriculumCategory.where(major: user.major , minor: false).group_by(&:id).flatten.flatten  \n      user.minor.each do |minor|\n        categories += CurriculumCategory.where(major: minor , minor: true).group_by(&:id).flatten.flatten  \n      end\n      \n      category_courses = categories.map { |category| (category.is_a?(CurriculumCategory)) ? category.curriculum_category_sets.group_by(&:id) : category }\n      category_courses = Hash[*category_courses]\n      \n      category_courses.each do |category_id, sets|\n        sets.each do |set_id, category_sets|\n          category_sets.map! do |category_course|\n            temp_courses = []\n            category_course.course_set.each do |set_course|\n              temp_courses << set_course.course\n            end\n            temp_courses\n          end\n        end\n      end\n      \n      category_courses.each do |category_id, sets|\n        sets.each do |set_id, category_sets|\n          category_sets.flatten!\n        end\n      end\n      \n      category_courses_tf = deep_copy(category_courses)\n      taken_courses = deep_copy(category_courses)\n      \n      category_courses_tf.each do |category_id, sets|\n        if not sets.blank?\n          sets.each do |set_id, set_courses|\n            set_courses.map! { |set_course| (user_courses.include?(set_course)) ? true : false }\n          end\n        else \n          category_courses_tf[category_id] = true\n        end\n      end\n      \n      complete_sets = []\n      category_courses_tf.each do |category_id, sets|\n        if sets.class.name == \"Hash\"\n          sets.each do |set_id, set_courses|\n            count = CurriculumCategorySet.find(set_id).count\n            if count != nil and set_courses.grep(true).count != count\n              category_courses_tf[category_id][set_id] = false\n            elsif count != nil and set_courses.grep(true).count == count\n              category_courses_tf[category_id][set_id] = true\n            elsif count == nil\n              category_courses_tf[category_id][set_id] = set_courses.inject(:&)\n            end\n          end\n          complete_sets <<  sets.select {|k,v| v }\n          CurriculumCategory.find(category_id).set_and_or_flag ? category_courses_tf[category_id] = sets.values.inject(:|) : category_courses_tf[category_id] = sets.values.inject(:&)\n        end\n      end  \n      \n      complete_sets.map!(&:keys).flatten!\n      category_courses_tf.keys.each { |key| category_courses_tf[key] ? category_courses_tf.delete(key) : false }\n      cats_unmet = category_courses_tf.keys\n      category_courses.select! {|k,v| cats_unmet.include?(k) }\n      \n      category_courses.each do |category_id, sets|\n        sets.each do |set_id, set_courses|\n          category_courses[category_id][set_id] = set_courses - user_courses\n        end\n        sets.keys.each { |key| complete_sets.include?(key) ? sets.delete(key) : false }\n        if CurriculumCategory.find(category_id).set_and_or_flag \n          temp = Hash.new\n          sets.each do |set_id, set_courses|\n            temp[set_id] = set_courses.count\n          end\n          min = temp.min.uniq[0]\n          temp.select! {|k,v| v > min }\n          sets.keys.each { |key| temp.keys.include?key ? sets.delete(key) : false }\n        end\n      end\n      \n      needs_list = []\n      category_courses.each do |category_id, sets|\n        sets.each do |set_id, set_courses|\n          category_courses[category_id][set_id] = prerequisite_check(set_courses, user_courses, user)\n        end\n        set_offerings = []\n        sets.each do |set_id, set_courses|\n          set_offerings = []\n          set_courses.each do |set_course|\n            if used_courses.add?(set_course)\n              offerings = Offering.where(course: set_course, semester: active_semester).flatten\n              if offerings.blank?\n                needs_list << set_course\n              else\n                set_offerings << offerings\n              end\n            end\n          end\n          category_courses[category_id][set_id]  = set_offerings.flatten\n        end\n      end\n      \n      needs_list.flatten!\n      NeededCourse.where(user: user, semester: active_semester).delete_all\n      inserts = []\n      needs_list.each do |course|\n        inserts.push \"(\" + user.id.to_s+ \", \" + course.id.to_s + \",\" + active_semester.id.to_s + \")\"\n      end\n      sql = \"INSERT INTO needed_courses (\\\"user_id\\\", \\\"course_id\\\", \\\"semester_id\\\") VALUES #{inserts.join(\", \")}\"\n      (ActiveRecord::Base.connection).execute sql\n      \n      taken_courses.each do |category_id, sets|\n        sets.each do |set_id, set_courses|\n          taken_courses[category_id][set_id] = set_courses & user_courses\n        end\n        if CurriculumCategory.find(category_id).set_and_or_flag \n          if not category_courses_tf.keys.include?category_id\n            first_complete = sets.keys.detect { |key| complete_sets.include?(key) }\n            sets.keys.each { |key| first_complete != key ? sets.delete(key) : false }\n          else\n            t = Hash.new\n            t[1] =sets.values.flatten.uniq\n            taken_courses[category_id] =t\n          end\n        end\n      end\n\n      return taken_courses, category_courses\n    end\n    \n    def deep_copy(o)\n      Marshal.load(Marshal.dump(o))\n    end\n    \n    def class_standing_compare(users_standing, min_standing)\n      if min_standing == nil\n        return true\n      else\n        standings = {1 => \"Senior\", 2 => \"Junior\", 3 => \"Sophmore\", 4 => \"Freshman\" }\n        users = standings.select { |k,v| v.include? users_standing }\n        min = standings.select { |k,v| v.include? min_standing }\n        if users.keys[0] <= min.keys[0]\n          return true\n        else \n          return false\n        end\n      end\n    end\n    \n    def sat_check(user, min_sat)\n      if min_sat == \"\" or min_sat == nil\n        return true\n      elsif min_sat == \"520\"\n        if user.sat_520\n          return true\n        else\n          return false\n        end\n      elsif min_sat == \"580\"\n        if user.sat_580\n          return true\n        else\n          return false\n        end\n      end\n    end\n    \n    def prereq_grade_checker(prereq, user_courses, transcripts)\n      if user_courses.include?(prereq.prerequisite_course)\n        if (prereq.minimum_grade == nil) or (prereq.minimum_grade == \"C\" and transcripts.where(course: prereq.prerequisite_course).take.grade_c) or (prereq.minimum_grade == \"C-\" and transcripts.where(course: prereq.prerequisite_course).take.grade_c_minus)\n          return true, nil\n        else \n          return false, prereq.prerequisite_course\n        end\n      else \n        return false, nil\n      end\n    end\nend\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"customSyntax":"ruby","scrolltop":1699.5,"scrollleft":0,"selection":{"start":{"row":114,"column":0},"end":{"row":114,"column":0},"isBackwards":false},"options":{"tabSize":2,"useSoftTabs":true,"guessTabSize":false,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":120,"state":"start","mode":"ace/mode/ruby"}},"timestamp":1426593319000}